note {Maze Generator using Recursive Backtracking}

// === Parameters ===
let cols = 10
let rows = 10
let cellSize = 5
let z_safe = 5
let z_cut = -1
let feed = 200

// === Initialize grid and walls ===
for y = 0..rows {
  for x = 0..cols {
    let visited_ = 0
    let wallTop_ = 1
    let wallRight_ = 1
    let wallBottom_ = 1
    let wallLeft_ = 1
  }
}

// === Stack Initialization ===
let stackTop = 1
let stackX_0 = 0
let stackY_0 = 0
visited_0_0 = 1

// === Recursive Backtracking Maze Builder ===
while (stackTop > 0) {
  let idx = stackTop - 1
  let cx = get("stackX_" + idx)
  let cy = get("stackY_" + idx)

  let nx = -1
  let ny = -1
  let found = 0

  if (cy > 0 && get("visited_" + cx + "_" + (cy - 1)) == 0) {
    nx = cx
    ny = cy - 1
    found = 1
  } else if (cx < cols - 1 && get("visited_" + (cx + 1) + "_" + cy) == 0) {
    nx = cx + 1
    ny = cy
    found = 1
  } else if (cy < rows - 1 && get("visited_" + cx + "_" + (cy + 1)) == 0) {
    nx = cx
    ny = cy + 1
    found = 1
  } else if (cx > 0 && get("visited_" + (cx - 1) + "_" + cy) == 0) {
    nx = cx - 1
    ny = cy
    found = 1
  }

  if (found == 1) {
    // Knock down walls between (cx, cy) and (nx, ny)
    if (nx == cx && ny == cy - 1) {
      set("wallTop_" + cx + "_" + cy, 0)
      set("wallBottom_" + nx + "_" + ny, 0)
    } else if (nx == cx + 1 && ny == cy) {
      set("wallRight_" + cx + "_" + cy, 0)
      set("wallLeft_" + nx + "_" + ny, 0)
    } else if (nx == cx && ny == cy + 1) {
      set("wallBottom_" + cx + "_" + cy, 0)
      set("wallTop_" + nx + "_" + ny, 0)
    } else if (nx == cx - 1 && ny == cy) {
      set("wallLeft_" + cx + "_" + cy, 0)
      set("wallRight_" + nx + "_" + ny, 0)
    }

    set("visited_" + nx + "_" + ny, 1)
    set("stackX_" + stackTop, nx)
    set("stackY_" + stackTop, ny)
    stackTop = stackTop + 1
  } else {
    stackTop = stackTop - 1
  }
}

// === Draw Maze Walls ===
G0 Z[z_safe]

for y = 0..rows {
  for x = 0..cols {
    let cx = x * cellSize
    let cy = y * cellSize
    let key = x + "_" + y

    if (get("wallTop_" + key) == 1) {
      G0 X[cx] Y[cy]
      G1 Z[z_cut] F[feed]
      G1 X[cx + cellSize] Y[cy] F[feed]
      G0 Z[z_safe]
    }

    if (get("wallRight_" + key) == 1) {
      G0 X[cx + cellSize] Y[cy]
      G1 Z[z_cut] F[feed]
      G1 X[cx + cellSize] Y[cy + cellSize] F[feed]
      G0 Z[z_safe]
    }

    if (get("wallBottom_" + key) == 1) {
      G0 X[cx] Y[cy + cellSize]
      G1 Z[z_cut] F[feed]
      G1 X[cx + cellSize] Y[cy + cellSize] F[feed]
      G0 Z[z_safe]
    }

    if (get("wallLeft_" + key) == 1) {
      G0 X[cx] Y[cy]
      G1 Z[z_cut] F[feed]
      G1 X[cx] Y[cy + cellSize] F[feed]
      G0 Z[z_safe]
    }
  }
}
