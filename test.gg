// // GGcode test file
// /* This GGcode comment does not get compiled */
let id = 22222
let test = 69

note {
  ╔═╗╔═╗┌─┐┌─┐┌┬┐┌─┐     File compiled : [ggcode_file_name]  
  ║ ╦║ ╦│  │ │ ││├┤      Timestamp : [time]  
  ╚═╝╚═╝└─┘└─┘─┴┘└─┘     Program ID: [id]  
  Test Value: [test]  
}

// let baseX = 1
// let baseY = 1
// let size = 2
// let offset = 3
// let z_start = 0
// let z_step = -0.05
// let z_final = -0.5
// let liftZ = 1
// let feed = 120

G90 G94 G17
G20
G53 G0 Z0
T1 M6
S6000 M3
G54
M8

// note {EXPECT: Loop 30 x 10 grid, each with 30 Z-depth passes}

// for j = 0..10 {
//     for i = 0..40 {
//         let x = baseX + i * offset
//         let y = baseY + j * offset

//         note {Start square [i],[j] at X[x] Y[y]}
//         G0 X[x] Y[y]
//         G43 Z[0] H[1]
//         G0 Z[liftZ]

//         for pass = 1..30 {
//             let z = z_start + pass * z_step
//             note {Pass [pass] > Z[z]}
//             G1 Z[z] F[feed]
//             G1 X[x + size] Y[y]
//             G1 X[x + size] Y[y + size]
//             G1 X[x]        Y[y + size]
//             G1 X[x]        Y[y]
//             G0 Z[liftZ]
//         }

//         note {Final finish pass on square [i],[j]}
//         G1 Z[z_final] F[feed]
//         G1 X[x + size]     Y[y]
//         G1 X[x + size]     Y[y + size]
//         G1 X[x]            Y[y + size]
//         G1 X[x]            Y[y]
//         G0 Z[liftZ]
//     }
// }

// let x = 0
// let y = 0
// let step_size = 2

// let dx = 1
// let dy = 0
// let segment_length = 1
// let segment_passed = 0
// let direction_changes = 0

// let liftZ = 1
// let z_depth = -0.05      // current Z depth
// let z_dir = -1           // wave direction
// let z_wave_step = 0.005   // step size for Z wave
// let z_wave_min = -10
// let z_wave_max = 0.0
// let feed = 120
// let size = 2

// note {Square Spiral Path with Z wave oscillation}

// for i = 1..5000 {
//     note {Step [i] at X[x] Y[y] Z[z_depth]}

//     G0 X[x] Y[y]
//     G43 Z[0] H[1]
//     G0 Z[liftZ]
//     G1 Z[z_depth] F[feed]

//     G1 X[x + size] Y[y]
//     G1 X[x + size] Y[y + size]
//     G1 X[x]        Y[y + size]
//     G1 X[x]        Y[y]
//     G0 Z[liftZ]

//     // Update X and Y for spiral
//     let x = x + dx * step_size
//     let y = y + dy * step_size

//     // Wave Z up and down
//     let z_depth = z_depth + z_dir * z_wave_step
//     if z_depth <= z_wave_min {
//         let z_depth = z_wave_min
//         let z_dir = 1
//     } else if z_depth >= z_wave_max {
//         let z_depth = z_wave_max
//         let z_dir = -1
//     }

//     // Track spiral turns
//     let segment_passed = segment_passed + 1
//     if segment_passed == segment_length {
//         let segment_passed = 0
//         let direction_changes = direction_changes + 1

//         // Rotate 90° clockwise
//         if dx == 1 && dy == 0 {
//             let dx = 0
//             let dy = 1
//         } else if dx == 0 && dy == 1 {
//             let dx = -1
//             let dy = 0
//         } else if dx == -1 && dy == 0 {
//             let dx = 0
//             let dy = -1
//         } else if dx == 0 && dy == -1 {
//             let dx = 1
//             let dy = 0
//         }

//         // Extend spiral arm every 2 turns
//         if direction_changes == 2 {
//             let segment_length = segment_length + 1
//             let direction_changes = 0
//         }
//     }
// }









// note {Spiral with Manual Rounding, No Jumps}

// let steps        = 180
// let angle_step   = 10
// let radius_step  = 0.1
// let z_safe       = 5
// let z_cut        = -1
// let feed         = 300
// let deg_to_rad   = DEG_TO_RAD
// let round_eps    = 0.0001

// // Basic round-to-3-decimals
// function round3(n) {
//     return floor(n * 1000 + 0.5) / 1000
// }

// // Clamp small values to 0
// function round_zero(n) {
//     if (abs(n) < round_eps) { return 0 }
//     return round3(n)
// }

// // Safe Start
// G0 Z[z_safe]
// G0 X0 Y0
// G1 Z[z_cut] F[feed]

// // Spiral Path
// for i = 1..500 {
//     angle_deg = i * angle_step
//     angle_rad = angle_deg * deg_to_rad
//     radius    = i * radius_step

//     raw_x = radius * cos(angle_rad)
//     raw_y = radius * sin(angle_rad)

//     x = round_zero(raw_x)
//     y = round_zero(raw_y)

//     G1 X[x] Y[y] F[feed]
// }

// // End
// G0 Z[z_safe]










// note {Rose Pattern - Polar Spiral with Petals}

// let k            = 4         // number of loops (petals)
// let loops        = 5         // number of full flower rotations
// let angle_step   = 2         // degrees per step
// let radius_base  = 5         // base radius
// let z_safe       = 5
// let z_cut        = -1
// let feed         = 300
// let deg_to_rad   = DEG_TO_RAD
// let round_eps    = 0.0001



// let y = 0
// let x = 0
// let angle_rad = 0
// let radius = 0
// let raw_x = 0
// let raw_y = 0

// let angle_deg = 0


// // Rounding Helpers
// function round3(n) {
//     return floor(n * 1000 + 0.5) / 1000
// }
// function round_zero(n) {
//     if (abs(n) < round_eps) { return 0 }
//     return round3(n)
// }

// // Safe Start
// G0 Z[z_safe]
// G0 X0 Y0
// G1 Z[z_cut] F[feed]

// // Flower Spiral Loop
// for angle_deg = 0..360  {
//     angle_rad = angle_deg * deg_to_rad

//     // Rose pattern radius: r = base * cos(k * θ)
//     radius = radius_base * cos(k * angle_rad)

//     raw_x = radius * cos(angle_rad)
//     raw_y = radius * sin(angle_rad)

//     x = round_zero(raw_x)
//     y = round_zero(raw_y)

//     G1 X[x] Y[y] F[feed]
// }

// // End
// G0 Z[z_safe]














// note {True Flower of Life Pattern — Radial Hex Packing}

// let radius      = 5
// let z_safe      = 5
// let z_cut       = -1
// let feed        = 300
// let step_deg    = 10
// let deg_to_rad  = DEG_TO_RAD
// let round_eps   = 0.0001

// let spacing     = radius
// let spacing_x   = spacing * 1.0
// let spacing_y   = spacing * sqrt(3) / 2

// // Hex direction vectors (flat-top orientation)
// let dir_x0 =  1
// let dir_y0 =  0
// let dir_x1 =  0.5
// let dir_y1 =  sqrt(3)/2
// let dir_x2 = -0.5
// let dir_y2 =  sqrt(3)/2
// let dir_x3 = -1
// let dir_y3 =  0
// let dir_x4 = -0.5
// let dir_y4 = -sqrt(3)/2
// let dir_x5 =  0.5
// let dir_y5 = -sqrt(3)/2

// // Start
// G0 Z[z_safe]

// // Loop over ring layers
// for layer = 0..3 {
//     // Step 0: center circle
//     if (layer == 0) {
//         let px = 0
//         let py = 0
//         // draw circle at px, py
//         angle = 0
//         raw_x = px + radius * cos(angle * deg_to_rad)
//         raw_y = py + radius * sin(angle * deg_to_rad)
//         x = floor(raw_x * 1000 + 0.5) / 1000
//         y = floor(raw_y * 1000 + 0.5) / 1000
//         G0 X[x] Y[y]
//         G1 Z[z_cut] F[feed]

//         for i = 1..360 {
//             angle = i * step_deg
//             raw_x = px + radius * cos(angle * deg_to_rad)
//             raw_y = py + radius * sin(angle * deg_to_rad)
//             x = floor(raw_x * 1000 + 0.5) / 1000
//             y = floor(raw_y * 1000 + 0.5) / 1000
//             if (abs(x) < round_eps) { x = 0 }
//             if (abs(y) < round_eps) { y = 0 }
//             G1 X[x] Y[y] F[feed]
//         }

//         G0 Z[z_safe]
//     }

//     // Step 1+: hexagonal ring around center
//     if (layer > 0) {
//         for side = 0..5 {
//             for step = 0..10 {
//                 dx = 0
//                 dy = 0

//                 // Move in one of 6 directions multiplied by step + rotation offset
//                 if (side == 0) {
//                     dx = layer - step
//                     dy = step
//                 }
//                 if (side == 1) {
//                     dx = -step
//                     dy = layer
//                 }
//                 if (side == 2) {
//                     dx = -layer
//                     dy = layer - step
//                 }
//                 if (side == 3) {
//                     dx = -layer + step
//                     dy = -step
//                 }
//                 if (side == 4) {
//                     dx = step
//                     dy = -layer
//                 }
//                 if (side == 5) {
//                     dx = layer
//                     dy = -layer + step
//                 }

//                 // Convert axial hex to XY
//                 px = dx * spacing_x + dy * spacing_x / 2
//                 py = dy * spacing_y * 2

//                 // draw circle at px, py
//                 angle = 0
//                 raw_x = px + radius * cos(angle * deg_to_rad)
//                 raw_y = py + radius * sin(angle * deg_to_rad)
//                 x = floor(raw_x * 1000 + 0.5) / 1000
//                 y = floor(raw_y * 1000 + 0.5) / 1000
//                 G0 X[x] Y[y]
//                 G1 Z[z_cut] F[feed]

//                 for i = 1..360 {
//                     angle = i * step_deg
//                     raw_x = px + radius * cos(angle * deg_to_rad)
//                     raw_y = py + radius * sin(angle * deg_to_rad)
//                     x = floor(raw_x * 1000 + 0.5) / 1000
//                     y = floor(raw_y * 1000 + 0.5) / 1000
//                     if (abs(x) < round_eps) { x = 0 }
//                     if (abs(y) < round_eps) { y = 0 }
//                     G1 X[x] Y[y] F[feed]
//                 }

//                 G0 Z[z_safe]
//             }
//         }
//     }
// }

































// note {Accurate Flower of Life - Pure Hex Packing Without Modulo}

// let radius      = 5
// let z_safe      = 5
// let z_cut       = -1
// let feed        = 300
// let step_deg    = 10
// let deg_to_rad  = DEG_TO_RAD
// let round_eps   = 0.0001

// let step_angle  = step_deg
// let spacing_x   = radius * 1.0
// let spacing_y   = radius * sqrt(3) / 2

// let cols = 13
// let rows = 13

// G0 Z[z_safe]

// // Loop rows and columns
// for row = 0..4 {
//     for col = 0..4 {
//         // Offset every other row by half-x spacing (using math instead of mod)
//         half_shift = (row - floor(row / 2) * 2) * 0.5 * spacing_x

//         cx = (col * spacing_x) + half_shift - (cols * spacing_x / 2)
//         cy = (row * spacing_y) - (rows * spacing_y / 2)

//         // Draw circle at (cx, cy)
//         angle = 0
//         raw_x = cx + radius * cos(angle * deg_to_rad)
//         raw_y = cy + radius * sin(angle * deg_to_rad)
//         x = floor(raw_x * 1000 + 0.5) / 1000
//         y = floor(raw_y * 1000 + 0.5) / 1000
//         G0 X[x] Y[y]
//         G1 Z[z_cut] F[feed]

//         for i = 1..360 {
//             angle = i * step_angle
//             raw_x = cx + radius * cos(angle * deg_to_rad)
//             raw_y = cy + radius * sin(angle * deg_to_rad)
//             x = floor(raw_x * 1000 + 0.5) / 1000
//             y = floor(raw_y * 1000 + 0.5) / 1000
//             if (abs(x) < round_eps) { x = 0 }
//             if (abs(y) < round_eps) { y = 0 }
//             G1 X[x] Y[y] F[feed]
//         }

//         G0 Z[z_safe]
//     }
// }

















// note {Flower of Life — Bounded with Circle Ring}

// // Settings
// let radius      = 5
// let z_safe      = 5
// let z_cut       = -1
// let feed        = 300
// let step_deg    = 10
// let deg_to_rad  = DEG_TO_RAD
// let round_eps   = 0.0001

// let spacing_x   = radius
// let spacing_y   = radius * sqrt(3) / 2
// let outer_r     = radius * 3.5  // outer boundary ring

// // Safe start
// G0 Z[z_safe]

// // Grid of circles (center-based, clipped to bounding circle)
// for row = -5..5 {
//     for col = -5..5 {
//         ox = col * spacing_x
//         oy = row * spacing_y

//         // Offset every other row
//         even = floor(row / 2) * 2
//         is_odd = row - even
//         if (is_odd == 1) {
//             ox = ox + spacing_x / 2
//         }

//         dist2 = ox * ox + oy * oy
//         if (dist2 > outer_r * outer_r) {
//             // skip if outside boundary
//         } else {
//             // Move to circle start
//             angle = 0
//             raw_x = ox + radius * cos(angle * deg_to_rad)
//             raw_y = oy + radius * sin(angle * deg_to_rad)
//             x = floor(raw_x * 1000 + 0.5) / 1000
//             y = floor(raw_y * 1000 + 0.5) / 1000
//             if (abs(x) < round_eps) { x = 0 }
//             if (abs(y) < round_eps) { y = 0 }

//             G0 X[x] Y[y]
//             G1 Z[z_cut] F[feed]

//             for i = 1..360 {
//                 angle = i * step_deg
//                 raw_x = ox + radius * cos(angle * deg_to_rad)
//                 raw_y = oy + radius * sin(angle * deg_to_rad)
//                 x = floor(raw_x * 1000 + 0.5) / 1000
//                 y = floor(raw_y * 1000 + 0.5) / 1000
//                 if (abs(x) < round_eps) { x = 0 }
//                 if (abs(y) < round_eps) { y = 0 }

//                 G1 X[x] Y[y] F[feed]
//             }

//             G0 Z[z_safe]
//         }
//     }
// }

// // Final outer ring
// G0 X[outer_r] Y0 Z[z_safe]
// G1 Z[z_cut] F[feed]
// for i = 1..360 {
//     angle = i * step_deg
//     x = outer_r * cos(angle * deg_to_rad)
//     y = outer_r * sin(angle * deg_to_rad)
//     x = floor(x * 1000 + 0.5) / 1000
//     y = floor(y * 1000 + 0.5) / 1000
//     if (abs(x) < round_eps) { x = 0 }
//     if (abs(y) < round_eps) { y = 0 }

//     G1 X[x] Y[y] F[feed]
// }
// G0 Z[z_safe]










let x = 5
let y = 10
let s = 2

// 1. Numeric bounds, inclusive, no step
for i = 0..5 {
    note { [i] }
}

// 2. Numeric bounds, inclusive, with step
for i = 0..5 step 2 {
    note { [i] }
}

// 3. Numeric bounds, exclusive, no step
for i = 0..<5 {
    note { [i] }
}

// 4. Numeric bounds, exclusive, with step
for i = 0..<5 step 2 {
    note { [i] }
}

// 5. Variable upper bound, inclusive, no step
for i = 0..x {
    note { [i] }
}

// 6. Variable upper bound, inclusive, with step
for i = 0..x step s {
    note { [i] }
}

// 7. Variable upper bound, exclusive, no step
for i = 0..<x {
    note { [i] }
}

// 8. Variable upper bound, exclusive, with step
for i = 0..<x step s {
    note { [i] }
}

// 9. Variable lower and upper bound, inclusive, with step
for i = x..y step s {
    note { [i] }
}

// 10. Variable lower and upper bound, exclusive, with step
for i = x..<y step s {
    note { [i] }
}

// 11. Expression as upper bound, inclusive, with step
for i = 0..(x + y) step (s + 1) {
    note { [i] }
}

// 12. Expression as lower and upper bound, exclusive, with step
for i = (x - 2)..<(y - 3) step (s * 2) {
    note { [i] }
}








// note {Flower of Life — Bounded with Circle Ring (Fixed Edge Connections)}

// // Settings
// let radius      = 5
// let z_safe      = 1
// let z_cut       = -1
// let feed        = 300
// let step_deg    = 3
// let deg_to_rad  = DEG_TO_RAD
// let round_eps   = 0.0001

// let spacing_x   = radius
// let spacing_y   = radius * sqrt(3) / 2
// let outer_r     = radius * 3.5

// G0 Z[z_safe]

// // Grid of clipped circles
// for row = -5..5 {
//     for col = -5..5 {
//         ox = col * spacing_x
//         oy = row * spacing_y

//         // Offset alternate rows
//         even = floor(row / 2) * 2
//         is_odd = row - even
//         ox = ox + is_odd * (spacing_x / 2)

//         // Process all circles — clip each point instead
//         let drawing = 0
//         let was_inside = 0
//         let point_count = 0
//         let first_x = 0
//         let first_y = 0
//         let prev_x = 999999
//         let prev_y = 999999

//         let i = 0
//         while (i <= 360) {
//             angle = i * deg_to_rad
//             raw_x = ox + radius * cos(angle)
//             raw_y = oy + radius * sin(angle)
//             d2 = raw_x * raw_x + raw_y * raw_y

//             // Clip exactly on outer boundary
//             if (abs(d2 - outer_r * outer_r) < round_eps) {
//                 scale = outer_r / sqrt(d2)
//                 raw_x = raw_x * scale
//                 raw_y = raw_y * scale
//             }

//             // Only draw points within final ring
//             inside = (raw_x * raw_x + raw_y * raw_y <= outer_r * outer_r + round_eps)

//             x = floor(raw_x * 1000 + 0.5) / 1000
//             y = floor(raw_y * 1000 + 0.5) / 1000
//             if (abs(x) < round_eps) { x = 0 }
//             if (abs(y) < round_eps) { y = 0 }

//             if (inside && was_inside == 0) {
//                 // Start of arc segment
//                 first_x = x
//                 first_y = y
//                 if (distance(x, y, prev_x, prev_y) > 0.01) {
//                     G0 Z[z_safe]
//                     G0 X[x] Y[y]
//                     G0 Z[z_cut] F[feed]
//                 } else {
//                     G1 X[x] Y[y] F[feed]
//                 }
//                 drawing = 1
//                 point_count = 1
//             } else if (inside && drawing == 1) {
//                 G1 X[x] Y[y] F[feed]
//                 point_count = point_count + 1
//             } else if (!inside && was_inside == 1 && drawing == 1) {
//                 // End of arc
//                 if (point_count > 1 && distance(x, y, first_x, first_y) < 0.5) {
//                     G1 X[first_x] Y[first_y] F[feed]
//                 }
//                 G0 Z[z_safe]
//                 drawing = 0
//                 point_count = 0
//             }

//             if (inside) {
//                 prev_x = x
//                 prev_y = y
//             }

//             was_inside = inside
//             i = i + step_deg
//         }

//         // Close loop if needed
//         if (drawing == 1 && distance(prev_x, prev_y, first_x, first_y) < 0.5) {
//             G1 X[first_x] Y[first_y] F[feed]
//             G0 Z[z_safe]
//         }
//     }
// }

// // Outer Ring
// G0 Z[z_safe]
// G0 X[outer_r] Y0


// // Outer Rings
// G0 Z[z_safe]

// for ring_scale = 1..6 {
//     r = outer_r + (ring_scale/10) - 0.3

//     G0 X[r] Y0
//     G0 Z[z_cut] F[feed]

//     let i = 0
//     while (i <= 360) {
//         angle = i * deg_to_rad
//         x = r * cos(angle)
//         y = r * sin(angle)
//         x = floor(x * 1000 + 0.5) / 1000
//         y = floor(y * 1000 + 0.5) / 1000
//         if (abs(x) < round_eps) { x = 0 }
//         if (abs(y) < round_eps) { y = 0 }
//         G1 X[x] Y[y] F[feed]
//         i = i + step_deg
//     }

//     G0 X[r] Y0 F[feed]
//     G0 Z[z_safe]
// }



