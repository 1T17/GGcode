<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GGcode Compiler</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #ddd;
      font-family: sans-serif;
      overflow: hidden;
    }

    #ggform {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .main-content {
      flex: 1;
      display: flex;
    }

    .left-panel,
    .right-panel {
      flex: 1;
      position: relative;
      border: 1px solid #444;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    #editor,
    #output {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .bottom-bar {
      height: 60px;
      background: #111;
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      border-top: 1px solid #333;
      padding: 0 20px;
    }

    .logo-button, .control-button {
      background: none;
      border: none;
      cursor: pointer;
      color: white;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-button img {
      width: 50px;
      height: auto;
    }

    .control-button img {
      width: 20px;
      height: 20px;
    }

    .control-button:hover {
      color: #6cf;
    }
  </style>
</head>
<body>

  <form id="ggform" action="/compile" method="POST" onsubmit="return submitGGcode(event)">
    <!-- Editor and Output -->
    <div class="main-content">
      <div class="left-panel"><div id="editor"></div></div>
      <div class="right-panel">
        <div id="output"></div>
      </div>
    </div>

    <textarea name="ggcode" id="ggcode" style="display:none;"><%= input %></textarea>

    <!-- Bottom Control Bar -->
    <div class="bottom-bar">
      <label style="display: flex; align-items: center; gap: 6px; font-size: 14px;">
        <input type="checkbox" id="autoCompileCheckbox" style="width: 18px; height: 18px;" />
        Auto-compile
      </label>


      <button type="submit" class="control-button" title="Compile GGcode">‚öôÔ∏è <span>Compile</span></button>

      <button type="button" class="control-button" id="openGGcodeBtn" title="Open GGcode file">üìÇ <span>Open GGcode</span></button>
      
      <button type="button" class="control-button" onclick="copyOutput()" title="Copy output G-code">
        üìã <span>Copy Gcode</span>
      </button>
      <button type="button" class="control-button" onclick="saveOutput()" title="Save output G-code to file">
        üíæ <span>Save Gcode</span>
      </button>
      <button type="button" class="control-button" onclick="saveGGcode()" title="Save GGcode input to file">
        üíæ <span>Save GGcode</span>
      </button>
      <button type="button" class="control-button" onclick="clearMemory()" title="Clear saved content and settings">
        üóëÔ∏è <span>Clear Memory</span>
      </button>
      <input type="file" id="ggcodeFileInput" accept=".ggcode,.txt" style="display:none;" />
    </div>
  </form>

  <!-- Monaco loader -->




  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <script>
    let editor, outputEditor;
    let monacoReady = false;
    let autoCompile = false;
    let autoCompileTimeout = null;
    let lastOpenedFilename = '';
    
    // Load saved filename on page load
    document.addEventListener('DOMContentLoaded', function() {
      const savedFilename = localStorage.getItem('ggcode_last_filename');
      if (savedFilename) {
        lastOpenedFilename = savedFilename;
      }
    });
    
    // Save content periodically and on page unload
    function saveContent() {
      if (editor) {
        localStorage.setItem('ggcode_input_content', editor.getValue());
      }
      if (outputEditor) {
        localStorage.setItem('ggcode_output_content', outputEditor.getValue());
      }
    }
    
    // Auto-save content every 30 seconds
    setInterval(saveContent, 30000);
    
    // Save content when page is about to unload
    window.addEventListener('beforeunload', saveContent);

    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });

    require(['vs/editor/editor.main'], function () {




monaco.languages.register({ id: 'ggcode' });

monaco.editor.defineTheme('ggcode-dark', {
  base: 'vs-dark',
  inherit: true,
  rules: [
    { token: 'keyword', foreground: '6FBAE3' },
    { token: 'gcode', foreground: '#F21B3F' },
    { token: 'axis', foreground: 'ff66cc' },
    { token: 'number', foreground: 'D0ECB1' },
    { token: 'comment', foreground: '#577834', fontStyle: 'italic' },
    { token: 'variable', foreground: 'ffaa00' },
    { token: 'constant', foreground: '00ff99' },
    { token: 'predefined', foreground: 'ff66cc' },
    { token: 'identifier', foreground: '#F5F5F5' },

  // Custom axis colors
    // Axis color-coded per CNC convention
{ token: 'axis.x', foreground: '#D9372B' },   // Soft red
{ token: 'axis.y', foreground: '#57C24F' },   // Soft green

{ token: 'axis.z', foreground: '#3B65B8' },   // Soft blue

{ token: 'axis.a', foreground: 'ff99ff' },   // Soft magenta
{ token: 'axis.b', foreground: '99ffff' },   // Soft cyan
{ token: 'axis.c', foreground: 'ffff99' },   // Soft yellow
{ token: 'axis.e', foreground: 'ffdddd' },   // Soft light red
{ token: 'axis.f', foreground: 'aaaaaa' },   // Soft gray
{ token: 'axis.s', foreground: 'ffbb66' },   // Soft orange
{ token: 'axis.t', foreground: 'dddddd' },   // Soft white
{ token: 'axis.h', foreground: 'bbbbff' },   // Soft light blue
{ token: 'axis.r', foreground: 'aaffaa' },   // Soft light green
{ token: 'axis.p', foreground: 'bbffff' },   // Soft pale cyan

{ token: 'axis.t', foreground: '#B02BD9' },   // Soft pale cyan

{ token: 'nline', foreground: '#5C5C5C' },   // Soft pale cyan

  ],
  colors: {} // ‚úÖ Add this line to prevent the crash
});



monaco.languages.setMonarchTokensProvider('ggcode', {
  keywords: ['let', 'if', 'else', 'for', 'while', 'function', 'return', 'note'],
  constants: ['PI', 'E', 'TAU', 'DEG_TO_RAD'],
  builtins: ['abs', 'mod', 'sin', 'cos', 'tan', 'sqrt', 'hypot', 'floor', 'ceil', 'round', 'clamp', 'distance'],

  operators: ['=', '+', '-', '*', '/', '%', '..'],
  symbols: /[=><!~?:&|+\-*\/\^%]+/,

  tokenizer: {
    root: [





// Axis with values (each treated separately)





// Axis with bracketed variables (e.g., X[f], Y[y+1])
[/\bX\[[^\]]+\]/, 'axis.x'],
[/\bY\[[^\]]+\]/, 'axis.y'],
[/\bZ\[[^\]]+\]/, 'axis.z'],
[/\bA\[[^\]]+\]/, 'axis.a'],
[/\bB\[[^\]]+\]/, 'axis.b'],
[/\bC\[[^\]]+\]/, 'axis.c'],
[/\bE\[[^\]]+\]/, 'axis.e'],
[/\bF\[[^\]]+\]/, 'axis.f'],
[/\bS\[[^\]]+\]/, 'axis.s'],
[/\bT\[[^\]]+\]/, 'axis.t'],
[/\bH\[[^\]]+\]/, 'axis.h'],
[/\bR\[[^\]]+\]/, 'axis.r'],
[/\bP\[[^\]]+\]/, 'axis.p'],

[/\bP\[[^\]]+\]/, 'axis.t'],



[/\bX[+-]?[0-9.]+\b/, 'axis.x'],
[/\bY[+-]?[0-9.]+\b/, 'axis.y'],
[/\bZ[+-]?[0-9.]+\b/, 'axis.z'],
[/\bA[+-]?[0-9.]+\b/, 'axis.a'],
[/\bB[+-]?[0-9.]+\b/, 'axis.b'],
[/\bC[+-]?[0-9.]+\b/, 'axis.c'],
[/\bE[+-]?[0-9.]+\b/, 'axis.e'],  // NEW
[/\bF[+-]?[0-9.]+\b/, 'axis.f'],
[/\bS[+-]?[0-9.]+\b/, 'axis.s'],
[/\bT[+-]?[0-9.]+\b/, 'axis.t'],
[/\bH[+-]?[0-9.]+\b/, 'axis.h'],
[/\bR[+-]?[0-9.]+\b/, 'axis.r'],
[/\bP[+-]?[0-9.]+\b/, 'axis.p'],

[/\bP[+-]?[0-9.]+\b/, 'axis.t'],

[/\bN[+-]?[0-9.]+\b/, 'nline'],

      // Keywords
      [/\b(let|if|else|for|while|function|return|note)\b/, 'keyword'],
      
      // Built-in constants
      [/\b(PI|E|TAU|DEG_TO_RAD)\b/, 'constant'],

      // Built-in functions
      [/\b(abs|mod|sin|cos|tan|sqrt|hypot|floor|ceil|round|clamp|distance)\b/, 'predefined'],

      // G-code / M-code
      [/\b(G\d+|M\d+)\b/, 'gcode'],

      // Axis with numeric values (X10, Y-5.5, etc.)
      [/\b([XYZABC][+-]?[0-9.]+)\b/, 'axis'],
      [/\b([FSTHRP][+-]?[0-9.]+)\b/, 'axis'],

      // Variables in brackets like [x], [x+1]
      [/\[[^\]]+\]/, 'variable'],

      // Numbers
      [/\b\d+(\.\d+)?\b/, 'number'],

      // Line comments
      [/\/\/.*$/, 'comment'],

      // Parenthesis-style G-code comments ( )
     // [/\([^)]*\)/, 'comment'],

      // Multiline comments /% ... %/
      [/%\/.*$/, 'comment', '@blockComment'],

      // Brackets and symbols
      [/[{}\[\]()]/, '@brackets'],





[/[a-zA-Z_]\w*/, {
  cases: {
    '@keywords': 'keyword',
    '@constants': 'constant',
    '@builtins': 'predefined',
    '@default': 'identifier'   // üü° highlight user-defined vars here
  }
}],







    ],

    blockComment: [
      [/.*%\//, 'comment', '@pop'],
      [/.*$/, 'comment']
    ]
  }
});
















      // Load saved content or use server-provided content
      let initialInput = `<%- input.replace(/`/g, '\`') %>`;
      let initialOutput = `<%- typeof output !== 'undefined' && output ? output.replace(/`/g, '\`') : '' %>`;
      
      // Check for saved content in localStorage
      const savedInput = localStorage.getItem('ggcode_input_content');
      const savedOutput = localStorage.getItem('ggcode_output_content');
      
      if (savedInput && savedInput.trim() !== '') {
        initialInput = savedInput;
      }
      if (savedOutput && savedOutput.trim() !== '') {
        initialOutput = savedOutput;
      }

      editor = monaco.editor.create(document.getElementById('editor'), {
        value: initialInput,
        language: 'ggcode',
        theme: 'ggcode-dark',
        automaticLayout: true,
        minimap: { enabled: true }
      });

      outputEditor = monaco.editor.create(document.getElementById('output'), {
        value: initialOutput,
        language: 'ggcode',
        theme: 'ggcode-dark',
        automaticLayout: true,
        minimap: { enabled: true }
      });
      monacoReady = true;

      // Auto-compile logic
      let skipAutoCompile = false;
      editor.onDidChangeModelContent(() => {
        if (autoCompile && !skipAutoCompile) {
          if (autoCompileTimeout) clearTimeout(autoCompileTimeout);
          autoCompileTimeout = setTimeout(() => {
            submitGGcode(new Event('submit'));
          }, 1000);
        }
        skipAutoCompile = false; // Reset flag after handling
      });

      // Drag-and-drop file support for editor
      const editorDom = document.getElementById('editor');
      if (editorDom) {
        editorDom.addEventListener('dragover', function(e) {
          e.preventDefault();
          editorDom.style.background = '#222a';
        });
        editorDom.addEventListener('dragleave', function(e) {
          e.preventDefault();
          editorDom.style.background = '';
        });
        editorDom.addEventListener('drop', function(e) {
          e.preventDefault();
          editorDom.style.background = '';
          if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            const reader = new FileReader();
            reader.onload = function(evt) {
              skipAutoCompile = true; // Skip auto-compile for file load
              if (editor) editor.setValue(evt.target.result);
              // Remember filename
              lastOpenedFilename = file.name || '';
              localStorage.setItem('ggcode_last_filename', lastOpenedFilename);
              // Direct compilation after file load
              submitGGcode(new Event('submit'));
            };
            reader.readAsText(file);
          }
        });
      }
    });

    // Auto-compile checkbox logic
    document.addEventListener('DOMContentLoaded', function() {
      const autoCheckbox = document.getElementById('autoCompileCheckbox');
      if (autoCheckbox) {
        // Load saved auto-compile state
        const savedAutoCompile = localStorage.getItem('ggcode_auto_compile');
        if (savedAutoCompile !== null) {
          autoCompile = savedAutoCompile === 'true';
          autoCheckbox.checked = autoCompile;
        }
        
        autoCheckbox.addEventListener('change', function() {
          autoCompile = autoCheckbox.checked;
          // Save auto-compile state to localStorage
          localStorage.setItem('ggcode_auto_compile', autoCompile.toString());
        });
      }
    });

    // Open GGcode file logic
    document.addEventListener('DOMContentLoaded', function() {
      const openBtn = document.getElementById('openGGcodeBtn');
      const fileInput = document.getElementById('ggcodeFileInput');
      if (openBtn && fileInput) {
        openBtn.addEventListener('click', function() {
          fileInput.value = '';
          fileInput.click();
        });
        fileInput.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function(evt) {
            skipAutoCompile = true; // Skip auto-compile for file load
            if (editor) editor.setValue(evt.target.result);
            // Remember filename
            lastOpenedFilename = file.name || '';
            localStorage.setItem('ggcode_last_filename', lastOpenedFilename);
            // Direct compilation after file load
            submitGGcode(new Event('submit'));
          };
          reader.readAsText(file);
        });
      }
    });

    function syncEditors() {
      document.getElementById('ggcode').value = editor.getValue();
    }

    async function submitGGcode(event) {
      event.preventDefault();
      if (!monacoReady) {
        alert("Editor is still loading. Please wait a moment and try again.");
        return false;
      }
      syncEditors();
      const code = editor.getValue();
      if (outputEditor) {
        outputEditor.setValue('Compiling...');
      }
      try {
        const response = await fetch('/api/compile', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ggcode: code })
        });
        const result = await response.json();
        if (result.success) {
          if (outputEditor) outputEditor.setValue(result.output);
          // Save content after successful compilation
          saveContent();
        } else {
          if (outputEditor) outputEditor.setValue('Error: ' + result.error);
        }
      } catch (err) {
        if (outputEditor) outputEditor.setValue('Network error: ' + err.message);
      }
      return false;
    }

    function copyOutput() {
      if (outputEditor) {
        navigator.clipboard.writeText(outputEditor.getValue())
          .catch(err => alert("Failed to copy: " + err));
      }
    }

    function saveOutput() {
      if (outputEditor) {
        const blob = new Blob([outputEditor.getValue()], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        // Improved filename logic for output
        let filename = '';
        if (lastOpenedFilename) {
          let base = lastOpenedFilename;
          if (base.endsWith('.gcode') || base.endsWith('.ggcode')) {
            base = base.replace(/\.(gcode|ggcode)$/i, '');
          } else if (base.lastIndexOf('.') > 0) {
            base = base.slice(0, base.lastIndexOf('.'));
          }
          filename = base + '.g.gcode';
        }
        if (!filename) filename = 'output.g.gcode';
        // Prompt user for filename
        const userFilename = window.prompt('Save G-code as:', filename);
        if (!userFilename) return; // Cancelled
        a.download = userFilename;
        a.click();
      }
    }

    function saveGGcode() {
      const blob = new Blob([editor.getValue()], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      let filename = lastOpenedFilename && lastOpenedFilename.endsWith('.ggcode') ? lastOpenedFilename : '';
      if (!filename && lastOpenedFilename) {
        // If opened file has another extension, use its base name with .ggcode
        const dot = lastOpenedFilename.lastIndexOf('.');
        filename = (dot > 0 ? lastOpenedFilename.slice(0, dot) : lastOpenedFilename) + '.ggcode';
      }
      if (!filename) filename = 'input.ggcode';
      // Prompt user for filename
      const userFilename = window.prompt('Save GGcode as:', filename);
      if (!userFilename) return; // Cancelled
      a.download = userFilename;
      a.click();
    }
    
    function clearMemory() {
      if (confirm('This will clear all saved content and settings. Are you sure?')) {
        // Clear localStorage
        localStorage.removeItem('ggcode_input_content');
        localStorage.removeItem('ggcode_output_content');
        localStorage.removeItem('ggcode_last_filename');
        localStorage.removeItem('ggcode_auto_compile');
        
        // Reset variables
        lastOpenedFilename = '';
        autoCompile = false;
        
        // Reset UI
        const autoCheckbox = document.getElementById('autoCompileCheckbox');
        if (autoCheckbox) {
          autoCheckbox.checked = false;
        }
        
        // Clear editors
        if (editor) {
          editor.setValue('');
        }
        if (outputEditor) {
          outputEditor.setValue('');
        }
        
        alert('Memory cleared successfully!');
      }
    }
  </script>



</body>
</html>
